{"name":"Controleuniversal","tagline":"Exercício 3 de 8 da Lista de Padrões de Projeto","body":"### Diagrama de Classes\r\n\r\nO diagrama representa a aplicação dos padrões State e Observador Implementados\r\n\r\n![](https://github.com/izabely-furtado/ControleUniversal/blob/master/Diagramas/Class%20DiagramStateObserver.png?raw=true)\r\n\r\n###Aplicação do Padrão State\r\n\r\n### Diagrama de Fluxos\r\n\r\nNo Diagrama de fluxos abaixo representa os estados da maquina\r\n\r\n![](https://github.com/izabely-furtado/ControleUniversal/blob/master/Diagramas/Fluxo%20de%20Estados.png?raw=true)\r\n\r\nConsiderando que o aparelho pode queimar de tanto ficar utilizando foi setado um valor padrão máximo de utilização. Assim definido como se há ou não há a possibilidade de mudança. Afinal o fluxo precisaria de um fim.\r\n\r\n**Explicação**\r\nAnalogamente ao implementado e explicado em [Link Maquina de Gomas](http://izabely-furtado.github.io/MaquinaGoma/) podemos notar que IMaquinaState é análogo IAparelhoState, assim como o +solicitaGoma(int moeda) é a +solicitaTrocaEstado() que nos AparelhoState estão representados das seguintes formas:\r\n\r\n* no estado Desligado, por exemplo:\r\n\r\n`\r\npublic class Desligado extends AparelhoState{\r\n\r\n    public Desligado(Aparelho ap) {\r\n        super(ap);\r\n    }\r\n\r\n    @Override\r\n    public void solicitaTrocarEstado() {\r\n        this._aparelho.setNovoEstado(new Ligado(this._aparelho));\r\n        this._aparelho.estado = true;\r\n        this._aparelho.solicitaTrocarEstado();\r\n    }\r\n`\r\nAnálogo ao Estado Ligado\r\n\r\n* no estado Queimado\r\n\r\n`\r\npublic class Queimado extends AparelhoState{\r\n\r\n    public Queimado(Aparelho ap) {\r\n        super(ap);\r\n    }\r\n\r\n    @Override\r\n    public void solicitaTrocarEstado() {\r\n        throw new UnsupportedOperationException(\"O aparelho queimou - troca\");\r\n    }\r\n    \r\n    @Override\r\n    public String toString(){\r\n        return \" :'( Já era\";\r\n    }\r\n}\r\n`\r\n\r\no THROW lançando uma exceção para a parada\r\n\r\nNo mais _maquina é análoga a _aparelho.\r\n\r\n###Aplicação do Padrão Observador\r\n\r\n### Representação da Relação de Observação\r\n\r\nNo Diagrama abaixo está representada a relação entre o observador (o Aparelho) e o observado (o Controle Remoto Universal).\r\n\r\n![](https://github.com/izabely-furtado/ControleUniversal/blob/master/Diagramas/Class%20DiagramRela%C3%A7%C3%A3oObserva%C3%A7%C3%A3o.png?raw=true)\r\n\r\nUma relação que se pode notar quem emite o sinal de comando (o Controle Remoto Universal) e quem executa em si o comando pedido (o Aparelho).\r\n\r\n**Explicação**\r\n\r\nAnalogamente ao implementado e explicado em [Link ArCondicionado](http://izabely-furtado.github.io/ArCondicionado/) podemos notar que no Observable (nesse caso como Aparelho) contém funções de registro, delete e notificação de cada observer (que nesse caso, só é um, o Controle Remoto Universal(CRU)) que foram implementadas num formato análogo, só que com determinadas mudanças no processo, identificadas a seguir.\r\n\r\nÉ dado o processo de controle seguindo esta sequência:\r\n\r\n* é feita a criação de um observer, sendo esse o CRU\r\n* se cria os aparelhos\r\n* se adiciona o CRU em cada um dos aparelhos\r\n* então se manipula as mudanças de estado, partindo de que o estado padrão é Desligado","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}